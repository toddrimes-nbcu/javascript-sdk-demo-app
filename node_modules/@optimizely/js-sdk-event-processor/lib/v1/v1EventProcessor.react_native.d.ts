/**
 * Copyright 2020, Optimizely
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { NotificationCenter } from '@optimizely/js-sdk-utils';
import { EventProcessor, ProcessableEvent } from "../eventProcessor";
import { EventQueue } from '../eventQueue';
import { EventDispatcher } from '../eventDispatcher';
/**
 * React Native Events Processor with Caching support for events when app is offline.
 */
export declare class LogTierV1EventProcessor implements EventProcessor {
    private dispatcher;
    queue: EventQueue<ProcessableEvent>;
    private notificationCenter?;
    private requestTracker;
    private unsubscribeNetInfo;
    private isInternetReachable;
    private pendingEventsPromise;
    private synchronizer;
    private shouldSkipDispatchToPreserveSequence;
    /**
     * This Stores Formatted events before dispatching. The events are removed after they are successfully dispatched.
     * Stored events are retried on every new event dispatch, when connection becomes available again or when SDK initializes the next time.
     */
    private pendingEventsStore;
    /**
     * This stores individual events generated from the SDK till they are part of the pending buffer.
     * The store is cleared right before the event is formatted to be dispatched.
     * This is to make sure that individual events are not lost when app closes before the buffer was flushed.
     */
    private eventBufferStore;
    constructor({ dispatcher, flushInterval, batchSize, maxQueueSize, notificationCenter, }: {
        dispatcher: EventDispatcher;
        flushInterval?: number;
        batchSize?: number;
        maxQueueSize?: number;
        notificationCenter?: NotificationCenter;
    });
    private connectionListener;
    private isSuccessResponse;
    private drainQueue;
    private processPendingEvents;
    private getPendingEventsPromise;
    private dispatchEvent;
    start(): Promise<void>;
    process(event: ProcessableEvent): void;
    stop(): Promise<void>;
}
