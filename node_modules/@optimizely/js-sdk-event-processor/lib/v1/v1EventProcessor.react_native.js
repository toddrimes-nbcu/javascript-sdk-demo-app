"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LogTierV1EventProcessor = void 0;
/**
 * Copyright 2020, Optimizely
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var js_sdk_utils_1 = require("@optimizely/js-sdk-utils");
var netinfo_1 = require("@react-native-community/netinfo");
var js_sdk_logging_1 = require("@optimizely/js-sdk-logging");
var eventProcessor_1 = require("../eventProcessor");
var reactNativeEventsStore_1 = require("../reactNativeEventsStore");
var synchronizer_1 = require("../synchronizer");
var requestTracker_1 = __importDefault(require("../requestTracker"));
var events_1 = require("../events");
var buildEventV1_1 = require("./buildEventV1");
var logger = js_sdk_logging_1.getLogger('ReactNativeEventProcessor');
var DEFAULT_MAX_QUEUE_SIZE = 10000;
var PENDING_EVENTS_STORE_KEY = 'fs_optly_pending_events';
var EVENT_BUFFER_STORE_KEY = 'fs_optly_event_buffer';
/**
 * React Native Events Processor with Caching support for events when app is offline.
 */
var LogTierV1EventProcessor = /** @class */ (function () {
    function LogTierV1EventProcessor(_a) {
        var dispatcher = _a.dispatcher, _b = _a.flushInterval, flushInterval = _b === void 0 ? eventProcessor_1.DEFAULT_FLUSH_INTERVAL : _b, _c = _a.batchSize, batchSize = _c === void 0 ? eventProcessor_1.DEFAULT_BATCH_SIZE : _c, _d = _a.maxQueueSize, maxQueueSize = _d === void 0 ? DEFAULT_MAX_QUEUE_SIZE : _d, notificationCenter = _a.notificationCenter;
        this.unsubscribeNetInfo = null;
        this.isInternetReachable = true;
        this.pendingEventsPromise = null;
        this.synchronizer = new synchronizer_1.Synchronizer();
        // If a pending event fails to dispatch, this indicates skipping further events to preserve sequence in the next retry.
        this.shouldSkipDispatchToPreserveSequence = false;
        this.dispatcher = dispatcher;
        this.notificationCenter = notificationCenter;
        this.requestTracker = new requestTracker_1.default();
        flushInterval = eventProcessor_1.validateAndGetFlushInterval(flushInterval);
        batchSize = eventProcessor_1.validateAndGetBatchSize(batchSize);
        this.queue = eventProcessor_1.getQueue(batchSize, flushInterval, this.drainQueue.bind(this), events_1.areEventContextsEqual);
        this.pendingEventsStore = new reactNativeEventsStore_1.ReactNativeEventsStore(maxQueueSize, PENDING_EVENTS_STORE_KEY);
        this.eventBufferStore = new reactNativeEventsStore_1.ReactNativeEventsStore(maxQueueSize, EVENT_BUFFER_STORE_KEY);
    }
    LogTierV1EventProcessor.prototype.connectionListener = function (state) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.isInternetReachable && !state.isInternetReachable) {
                            this.isInternetReachable = false;
                            logger.debug('Internet connection lost');
                            return [2 /*return*/];
                        }
                        if (!(!this.isInternetReachable && state.isInternetReachable)) return [3 /*break*/, 2];
                        this.isInternetReachable = true;
                        logger.debug('Internet connection is restored, attempting to dispatch pending events');
                        return [4 /*yield*/, this.processPendingEvents()];
                    case 1:
                        _a.sent();
                        this.shouldSkipDispatchToPreserveSequence = false;
                        _a.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        });
    };
    LogTierV1EventProcessor.prototype.isSuccessResponse = function (status) {
        return status >= 200 && status < 400;
    };
    LogTierV1EventProcessor.prototype.drainQueue = function (buffer) {
        return __awaiter(this, void 0, void 0, function () {
            var eventCacheKey, formattedEvent, _i, buffer_1, uuid;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (buffer.length === 0) {
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, this.synchronizer.getLock()
                            // Retry pending failed events while draining queue
                        ];
                    case 1:
                        _a.sent();
                        // Retry pending failed events while draining queue
                        return [4 /*yield*/, this.processPendingEvents()];
                    case 2:
                        // Retry pending failed events while draining queue
                        _a.sent();
                        logger.debug('draining queue with %s events', buffer.length);
                        eventCacheKey = js_sdk_utils_1.generateUUID();
                        formattedEvent = buildEventV1_1.formatEvents(buffer);
                        // Store formatted event before dispatching to be retried later in case of failure.
                        return [4 /*yield*/, this.pendingEventsStore.set(eventCacheKey, formattedEvent)
                            // Clear buffer because the buffer has become a formatted event and is already stored in pending cache.
                        ];
                    case 3:
                        // Store formatted event before dispatching to be retried later in case of failure.
                        _a.sent();
                        _i = 0, buffer_1 = buffer;
                        _a.label = 4;
                    case 4:
                        if (!(_i < buffer_1.length)) return [3 /*break*/, 7];
                        uuid = buffer_1[_i].uuid;
                        return [4 /*yield*/, this.eventBufferStore.remove(uuid)];
                    case 5:
                        _a.sent();
                        _a.label = 6;
                    case 6:
                        _i++;
                        return [3 /*break*/, 4];
                    case 7:
                        if (!!this.shouldSkipDispatchToPreserveSequence) return [3 /*break*/, 9];
                        return [4 /*yield*/, this.dispatchEvent(eventCacheKey, formattedEvent)];
                    case 8:
                        _a.sent();
                        _a.label = 9;
                    case 9:
                        // Resetting skip flag because current sequence of events have all been processed
                        this.shouldSkipDispatchToPreserveSequence = false;
                        this.synchronizer.releaseLock();
                        return [2 /*return*/];
                }
            });
        });
    };
    LogTierV1EventProcessor.prototype.processPendingEvents = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        logger.debug('Processing pending events from offline storage');
                        if (!this.pendingEventsPromise) {
                            // Only process events if existing promise is not in progress
                            this.pendingEventsPromise = this.getPendingEventsPromise();
                        }
                        else {
                            logger.debug('Already processing pending events, returning the existing promise');
                        }
                        return [4 /*yield*/, this.pendingEventsPromise];
                    case 1:
                        _a.sent();
                        this.pendingEventsPromise = null;
                        return [2 /*return*/];
                }
            });
        });
    };
    LogTierV1EventProcessor.prototype.getPendingEventsPromise = function () {
        return __awaiter(this, void 0, void 0, function () {
            var formattedEvents, eventEntries, _i, eventEntries_1, _a, eventKey, event_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.pendingEventsStore.getEventsMap()];
                    case 1:
                        formattedEvents = _b.sent();
                        eventEntries = js_sdk_utils_1.objectEntries(formattedEvents);
                        logger.debug('Processing %s pending events', eventEntries.length);
                        _i = 0, eventEntries_1 = eventEntries;
                        _b.label = 2;
                    case 2:
                        if (!(_i < eventEntries_1.length)) return [3 /*break*/, 5];
                        _a = eventEntries_1[_i], eventKey = _a[0], event_1 = _a[1];
                        // If one event dispatch failed, skip subsequent events to preserve sequence
                        if (this.shouldSkipDispatchToPreserveSequence) {
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, this.dispatchEvent(eventKey, event_1)];
                    case 3:
                        _b.sent();
                        _b.label = 4;
                    case 4:
                        _i++;
                        return [3 /*break*/, 2];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    LogTierV1EventProcessor.prototype.dispatchEvent = function (eventCacheKey, event) {
        return __awaiter(this, void 0, void 0, function () {
            var requestPromise;
            var _this = this;
            return __generator(this, function (_a) {
                requestPromise = new Promise(function (resolve) {
                    _this.dispatcher.dispatchEvent(event, function (_a) {
                        var statusCode = _a.statusCode;
                        return __awaiter(_this, void 0, void 0, function () {
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        if (!this.isSuccessResponse(statusCode)) return [3 /*break*/, 2];
                                        return [4 /*yield*/, this.pendingEventsStore.remove(eventCacheKey)];
                                    case 1:
                                        _b.sent();
                                        return [3 /*break*/, 3];
                                    case 2:
                                        this.shouldSkipDispatchToPreserveSequence = true;
                                        logger.warn('Failed to dispatch event, Response status Code: %s', statusCode);
                                        _b.label = 3;
                                    case 3:
                                        resolve();
                                        return [2 /*return*/];
                                }
                            });
                        });
                    });
                    eventProcessor_1.sendEventNotification(_this.notificationCenter, event);
                });
                // Tracking all the requests to dispatch to make sure request is completed before fulfilling the `stop` promise
                this.requestTracker.trackRequest(requestPromise);
                return [2 /*return*/, requestPromise];
            });
        });
    };
    LogTierV1EventProcessor.prototype.start = function () {
        return __awaiter(this, void 0, void 0, function () {
            var events;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.queue.start();
                        this.unsubscribeNetInfo = netinfo_1.addEventListener(this.connectionListener.bind(this));
                        return [4 /*yield*/, this.processPendingEvents()];
                    case 1:
                        _a.sent();
                        this.shouldSkipDispatchToPreserveSequence = false;
                        return [4 /*yield*/, this.eventBufferStore.getEventsList()];
                    case 2:
                        events = _a.sent();
                        return [4 /*yield*/, this.eventBufferStore.clear()];
                    case 3:
                        _a.sent();
                        events.forEach(this.process.bind(this));
                        return [2 /*return*/];
                }
            });
        });
    };
    LogTierV1EventProcessor.prototype.process = function (event) {
        var _this = this;
        // Adding events to buffer store. If app closes before dispatch, we can reprocess next time the app initializes
        this.eventBufferStore.set(event.uuid, event).then(function () {
            _this.queue.enqueue(event);
        });
    };
    LogTierV1EventProcessor.prototype.stop = function () {
        return __awaiter(this, void 0, void 0, function () {
            var e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        this.unsubscribeNetInfo && this.unsubscribeNetInfo();
                        return [4 /*yield*/, this.queue.stop()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, this.requestTracker.onRequestsComplete()];
                    case 2:
                        e_1 = _a.sent();
                        logger.error('Error stopping EventProcessor: "%s"', e_1.message, e_1);
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    return LogTierV1EventProcessor;
}());
exports.LogTierV1EventProcessor = LogTierV1EventProcessor;
